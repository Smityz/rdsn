/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "meta_admin_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace dsn { namespace replication {

int _kconfig_typeValues[] = {
  config_type::CT_INVALID,
  config_type::CT_ASSIGN_PRIMARY,
  config_type::CT_UPGRADE_TO_PRIMARY,
  config_type::CT_ADD_SECONDARY,
  config_type::CT_UPGRADE_TO_SECONDARY,
  config_type::CT_DOWNGRADE_TO_SECONDARY,
  config_type::CT_DOWNGRADE_TO_INACTIVE,
  config_type::CT_REMOVE,
  config_type::CT_ADD_SECONDARY_FOR_LB,
  config_type::CT_PRIMARY_FORCE_UPDATE_BALLOT,
  config_type::CT_DROP_PARTITION,
  config_type::CT_REGISTER_CHILD
};
const char* _kconfig_typeNames[] = {
  "CT_INVALID",
  "CT_ASSIGN_PRIMARY",
  "CT_UPGRADE_TO_PRIMARY",
  "CT_ADD_SECONDARY",
  "CT_UPGRADE_TO_SECONDARY",
  "CT_DOWNGRADE_TO_SECONDARY",
  "CT_DOWNGRADE_TO_INACTIVE",
  "CT_REMOVE",
  "CT_ADD_SECONDARY_FOR_LB",
  "CT_PRIMARY_FORCE_UPDATE_BALLOT",
  "CT_DROP_PARTITION",
  "CT_REGISTER_CHILD"
};
const std::map<int, const char*> _config_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(12, _kconfig_typeValues, _kconfig_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _knode_statusValues[] = {
  node_status::NS_INVALID,
  node_status::NS_ALIVE,
  node_status::NS_UNALIVE
};
const char* _knode_statusNames[] = {
  "NS_INVALID",
  "NS_ALIVE",
  "NS_UNALIVE"
};
const std::map<int, const char*> _node_status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _knode_statusValues, _knode_statusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kapp_env_operationValues[] = {
  app_env_operation::APP_ENV_OP_INVALID,
  app_env_operation::APP_ENV_OP_SET,
  app_env_operation::APP_ENV_OP_DEL,
  app_env_operation::APP_ENV_OP_CLEAR
};
const char* _kapp_env_operationNames[] = {
  "APP_ENV_OP_INVALID",
  "APP_ENV_OP_SET",
  "APP_ENV_OP_DEL",
  "APP_ENV_OP_CLEAR"
};
const std::map<int, const char*> _app_env_operation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kapp_env_operationValues, _kapp_env_operationNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kmeta_function_levelValues[] = {
  meta_function_level::fl_stopped,
  meta_function_level::fl_blind,
  meta_function_level::fl_freezed,
  meta_function_level::fl_steady,
  meta_function_level::fl_lively,
  meta_function_level::fl_invalid
};
const char* _kmeta_function_levelNames[] = {
  "fl_stopped",
  "fl_blind",
  "fl_freezed",
  "fl_steady",
  "fl_lively",
  "fl_invalid"
};
const std::map<int, const char*> _meta_function_level_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kmeta_function_levelValues, _kmeta_function_levelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kbalancer_request_typeValues[] = {
  balancer_request_type::move_primary,
  balancer_request_type::copy_primary,
  balancer_request_type::copy_secondary
};
const char* _kbalancer_request_typeNames[] = {
  "move_primary",
  "copy_primary",
  "copy_secondary"
};
const std::map<int, const char*> _balancer_request_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kbalancer_request_typeValues, _kbalancer_request_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


configuration_update_request::~configuration_update_request() throw() {
}


void configuration_update_request::__set_info(const  ::dsn::app_info& val) {
  this->info = val;
}

void configuration_update_request::__set_config(const  ::dsn::partition_configuration& val) {
  this->config = val;
}

void configuration_update_request::__set_type(const config_type::type val) {
  this->type = val;
}

void configuration_update_request::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

void configuration_update_request::__set_host_node(const  ::dsn::rpc_address& val) {
  this->host_node = val;
}

void configuration_update_request::__set_meta_split_status(const  ::dsn::replication::split_status::type val) {
  this->meta_split_status = val;
__isset.meta_split_status = true;
}

uint32_t configuration_update_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->info.read(iprot);
          this->__isset.info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->config.read(iprot);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (config_type::type)ecast0;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->host_node.read(iprot);
          this->__isset.host_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->meta_split_status = ( ::dsn::replication::split_status::type)ecast1;
          this->__isset.meta_split_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_update_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_update_request");

  xfer += oprot->writeFieldBegin("info", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->info.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("host_node", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->host_node.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.meta_split_status) {
    xfer += oprot->writeFieldBegin("meta_split_status", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->meta_split_status);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_update_request &a, configuration_update_request &b) {
  using ::std::swap;
  swap(a.info, b.info);
  swap(a.config, b.config);
  swap(a.type, b.type);
  swap(a.node, b.node);
  swap(a.host_node, b.host_node);
  swap(a.meta_split_status, b.meta_split_status);
  swap(a.__isset, b.__isset);
}

configuration_update_request::configuration_update_request(const configuration_update_request& other2) {
  info = other2.info;
  config = other2.config;
  type = other2.type;
  node = other2.node;
  host_node = other2.host_node;
  meta_split_status = other2.meta_split_status;
  __isset = other2.__isset;
}
configuration_update_request& configuration_update_request::operator=(const configuration_update_request& other3) {
  info = other3.info;
  config = other3.config;
  type = other3.type;
  node = other3.node;
  host_node = other3.host_node;
  meta_split_status = other3.meta_split_status;
  __isset = other3.__isset;
  return *this;
}
void configuration_update_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_update_request(";
  out << "info=" << to_string(info);
  out << ", " << "config=" << to_string(config);
  out << ", " << "type=" << to_string(type);
  out << ", " << "node=" << to_string(node);
  out << ", " << "host_node=" << to_string(host_node);
  out << ", " << "meta_split_status="; (__isset.meta_split_status ? (out << to_string(meta_split_status)) : (out << "<null>"));
  out << ")";
}


configuration_update_response::~configuration_update_response() throw() {
}


void configuration_update_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_update_response::__set_config(const  ::dsn::partition_configuration& val) {
  this->config = val;
}

uint32_t configuration_update_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->config.read(iprot);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_update_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_update_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_update_response &a, configuration_update_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.config, b.config);
  swap(a.__isset, b.__isset);
}

configuration_update_response::configuration_update_response(const configuration_update_response& other4) {
  err = other4.err;
  config = other4.config;
  __isset = other4.__isset;
}
configuration_update_response& configuration_update_response::operator=(const configuration_update_response& other5) {
  err = other5.err;
  config = other5.config;
  __isset = other5.__isset;
  return *this;
}
void configuration_update_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_update_response(";
  out << "err=" << to_string(err);
  out << ", " << "config=" << to_string(config);
  out << ")";
}


replica_server_info::~replica_server_info() throw() {
}


void replica_server_info::__set_geo_tags(const std::map<std::string, std::string> & val) {
  this->geo_tags = val;
}

void replica_server_info::__set_total_capacity_mb(const int64_t val) {
  this->total_capacity_mb = val;
}

uint32_t replica_server_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->geo_tags.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _ktype7;
            ::apache::thrift::protocol::TType _vtype8;
            xfer += iprot->readMapBegin(_ktype7, _vtype8, _size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              std::string _key11;
              xfer += iprot->readString(_key11);
              std::string& _val12 = this->geo_tags[_key11];
              xfer += iprot->readString(_val12);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.geo_tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_capacity_mb);
          this->__isset.total_capacity_mb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t replica_server_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("replica_server_info");

  xfer += oprot->writeFieldBegin("geo_tags", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->geo_tags.size()));
    std::map<std::string, std::string> ::const_iterator _iter13;
    for (_iter13 = this->geo_tags.begin(); _iter13 != this->geo_tags.end(); ++_iter13)
    {
      xfer += oprot->writeString(_iter13->first);
      xfer += oprot->writeString(_iter13->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_capacity_mb", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->total_capacity_mb);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(replica_server_info &a, replica_server_info &b) {
  using ::std::swap;
  swap(a.geo_tags, b.geo_tags);
  swap(a.total_capacity_mb, b.total_capacity_mb);
  swap(a.__isset, b.__isset);
}

replica_server_info::replica_server_info(const replica_server_info& other14) {
  geo_tags = other14.geo_tags;
  total_capacity_mb = other14.total_capacity_mb;
  __isset = other14.__isset;
}
replica_server_info& replica_server_info::operator=(const replica_server_info& other15) {
  geo_tags = other15.geo_tags;
  total_capacity_mb = other15.total_capacity_mb;
  __isset = other15.__isset;
  return *this;
}
void replica_server_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "replica_server_info(";
  out << "geo_tags=" << to_string(geo_tags);
  out << ", " << "total_capacity_mb=" << to_string(total_capacity_mb);
  out << ")";
}


configuration_query_by_node_request::~configuration_query_by_node_request() throw() {
}


void configuration_query_by_node_request::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

void configuration_query_by_node_request::__set_stored_replicas(const std::vector< ::dsn::replication::replica_info> & val) {
  this->stored_replicas = val;
__isset.stored_replicas = true;
}

void configuration_query_by_node_request::__set_info(const replica_server_info& val) {
  this->info = val;
__isset.info = true;
}

uint32_t configuration_query_by_node_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stored_replicas.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->stored_replicas.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += this->stored_replicas[_i20].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stored_replicas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->info.read(iprot);
          this->__isset.info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_query_by_node_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_query_by_node_request");

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.stored_replicas) {
    xfer += oprot->writeFieldBegin("stored_replicas", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->stored_replicas.size()));
      std::vector< ::dsn::replication::replica_info> ::const_iterator _iter21;
      for (_iter21 = this->stored_replicas.begin(); _iter21 != this->stored_replicas.end(); ++_iter21)
      {
        xfer += (*_iter21).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.info) {
    xfer += oprot->writeFieldBegin("info", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_query_by_node_request &a, configuration_query_by_node_request &b) {
  using ::std::swap;
  swap(a.node, b.node);
  swap(a.stored_replicas, b.stored_replicas);
  swap(a.info, b.info);
  swap(a.__isset, b.__isset);
}

configuration_query_by_node_request::configuration_query_by_node_request(const configuration_query_by_node_request& other22) {
  node = other22.node;
  stored_replicas = other22.stored_replicas;
  info = other22.info;
  __isset = other22.__isset;
}
configuration_query_by_node_request& configuration_query_by_node_request::operator=(const configuration_query_by_node_request& other23) {
  node = other23.node;
  stored_replicas = other23.stored_replicas;
  info = other23.info;
  __isset = other23.__isset;
  return *this;
}
void configuration_query_by_node_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_query_by_node_request(";
  out << "node=" << to_string(node);
  out << ", " << "stored_replicas="; (__isset.stored_replicas ? (out << to_string(stored_replicas)) : (out << "<null>"));
  out << ", " << "info="; (__isset.info ? (out << to_string(info)) : (out << "<null>"));
  out << ")";
}


configuration_query_by_node_response::~configuration_query_by_node_response() throw() {
}


void configuration_query_by_node_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_query_by_node_response::__set_partitions(const std::vector<configuration_update_request> & val) {
  this->partitions = val;
}

void configuration_query_by_node_response::__set_gc_replicas(const std::vector< ::dsn::replication::replica_info> & val) {
  this->gc_replicas = val;
__isset.gc_replicas = true;
}

uint32_t configuration_query_by_node_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _etype27;
            xfer += iprot->readListBegin(_etype27, _size24);
            this->partitions.resize(_size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              xfer += this->partitions[_i28].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->gc_replicas.clear();
            uint32_t _size29;
            ::apache::thrift::protocol::TType _etype32;
            xfer += iprot->readListBegin(_etype32, _size29);
            this->gc_replicas.resize(_size29);
            uint32_t _i33;
            for (_i33 = 0; _i33 < _size29; ++_i33)
            {
              xfer += this->gc_replicas[_i33].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.gc_replicas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_query_by_node_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_query_by_node_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<configuration_update_request> ::const_iterator _iter34;
    for (_iter34 = this->partitions.begin(); _iter34 != this->partitions.end(); ++_iter34)
    {
      xfer += (*_iter34).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.gc_replicas) {
    xfer += oprot->writeFieldBegin("gc_replicas", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->gc_replicas.size()));
      std::vector< ::dsn::replication::replica_info> ::const_iterator _iter35;
      for (_iter35 = this->gc_replicas.begin(); _iter35 != this->gc_replicas.end(); ++_iter35)
      {
        xfer += (*_iter35).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_query_by_node_response &a, configuration_query_by_node_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.partitions, b.partitions);
  swap(a.gc_replicas, b.gc_replicas);
  swap(a.__isset, b.__isset);
}

configuration_query_by_node_response::configuration_query_by_node_response(const configuration_query_by_node_response& other36) {
  err = other36.err;
  partitions = other36.partitions;
  gc_replicas = other36.gc_replicas;
  __isset = other36.__isset;
}
configuration_query_by_node_response& configuration_query_by_node_response::operator=(const configuration_query_by_node_response& other37) {
  err = other37.err;
  partitions = other37.partitions;
  gc_replicas = other37.gc_replicas;
  __isset = other37.__isset;
  return *this;
}
void configuration_query_by_node_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_query_by_node_response(";
  out << "err=" << to_string(err);
  out << ", " << "partitions=" << to_string(partitions);
  out << ", " << "gc_replicas="; (__isset.gc_replicas ? (out << to_string(gc_replicas)) : (out << "<null>"));
  out << ")";
}


configuration_recovery_request::~configuration_recovery_request() throw() {
}


void configuration_recovery_request::__set_recovery_set(const std::vector< ::dsn::rpc_address> & val) {
  this->recovery_set = val;
}

void configuration_recovery_request::__set_skip_bad_nodes(const bool val) {
  this->skip_bad_nodes = val;
}

void configuration_recovery_request::__set_skip_lost_partitions(const bool val) {
  this->skip_lost_partitions = val;
}

uint32_t configuration_recovery_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->recovery_set.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->recovery_set.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += this->recovery_set[_i42].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.recovery_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->skip_bad_nodes);
          this->__isset.skip_bad_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->skip_lost_partitions);
          this->__isset.skip_lost_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_recovery_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_recovery_request");

  xfer += oprot->writeFieldBegin("recovery_set", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->recovery_set.size()));
    std::vector< ::dsn::rpc_address> ::const_iterator _iter43;
    for (_iter43 = this->recovery_set.begin(); _iter43 != this->recovery_set.end(); ++_iter43)
    {
      xfer += (*_iter43).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skip_bad_nodes", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->skip_bad_nodes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skip_lost_partitions", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->skip_lost_partitions);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_recovery_request &a, configuration_recovery_request &b) {
  using ::std::swap;
  swap(a.recovery_set, b.recovery_set);
  swap(a.skip_bad_nodes, b.skip_bad_nodes);
  swap(a.skip_lost_partitions, b.skip_lost_partitions);
  swap(a.__isset, b.__isset);
}

configuration_recovery_request::configuration_recovery_request(const configuration_recovery_request& other44) {
  recovery_set = other44.recovery_set;
  skip_bad_nodes = other44.skip_bad_nodes;
  skip_lost_partitions = other44.skip_lost_partitions;
  __isset = other44.__isset;
}
configuration_recovery_request& configuration_recovery_request::operator=(const configuration_recovery_request& other45) {
  recovery_set = other45.recovery_set;
  skip_bad_nodes = other45.skip_bad_nodes;
  skip_lost_partitions = other45.skip_lost_partitions;
  __isset = other45.__isset;
  return *this;
}
void configuration_recovery_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_recovery_request(";
  out << "recovery_set=" << to_string(recovery_set);
  out << ", " << "skip_bad_nodes=" << to_string(skip_bad_nodes);
  out << ", " << "skip_lost_partitions=" << to_string(skip_lost_partitions);
  out << ")";
}


configuration_recovery_response::~configuration_recovery_response() throw() {
}


void configuration_recovery_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_recovery_response::__set_hint_message(const std::string& val) {
  this->hint_message = val;
}

uint32_t configuration_recovery_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_message);
          this->__isset.hint_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_recovery_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_recovery_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hint_message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hint_message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_recovery_response &a, configuration_recovery_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.hint_message, b.hint_message);
  swap(a.__isset, b.__isset);
}

configuration_recovery_response::configuration_recovery_response(const configuration_recovery_response& other46) {
  err = other46.err;
  hint_message = other46.hint_message;
  __isset = other46.__isset;
}
configuration_recovery_response& configuration_recovery_response::operator=(const configuration_recovery_response& other47) {
  err = other47.err;
  hint_message = other47.hint_message;
  __isset = other47.__isset;
  return *this;
}
void configuration_recovery_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_recovery_response(";
  out << "err=" << to_string(err);
  out << ", " << "hint_message=" << to_string(hint_message);
  out << ")";
}


create_app_options::~create_app_options() throw() {
}


void create_app_options::__set_partition_count(const int32_t val) {
  this->partition_count = val;
}

void create_app_options::__set_replica_count(const int32_t val) {
  this->replica_count = val;
}

void create_app_options::__set_success_if_exist(const bool val) {
  this->success_if_exist = val;
}

void create_app_options::__set_app_type(const std::string& val) {
  this->app_type = val;
}

void create_app_options::__set_is_stateful(const bool val) {
  this->is_stateful = val;
}

void create_app_options::__set_envs(const std::map<std::string, std::string> & val) {
  this->envs = val;
}

uint32_t create_app_options::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_count);
          this->__isset.partition_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->replica_count);
          this->__isset.replica_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success_if_exist);
          this->__isset.success_if_exist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_type);
          this->__isset.app_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_stateful);
          this->__isset.is_stateful = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->envs.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _ktype49;
            ::apache::thrift::protocol::TType _vtype50;
            xfer += iprot->readMapBegin(_ktype49, _vtype50, _size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              std::string _key53;
              xfer += iprot->readString(_key53);
              std::string& _val54 = this->envs[_key53];
              xfer += iprot->readString(_val54);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.envs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t create_app_options::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("create_app_options");

  xfer += oprot->writeFieldBegin("partition_count", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->partition_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("replica_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->replica_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("success_if_exist", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->success_if_exist);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->app_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_stateful", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_stateful);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("envs", ::apache::thrift::protocol::T_MAP, 6);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->envs.size()));
    std::map<std::string, std::string> ::const_iterator _iter55;
    for (_iter55 = this->envs.begin(); _iter55 != this->envs.end(); ++_iter55)
    {
      xfer += oprot->writeString(_iter55->first);
      xfer += oprot->writeString(_iter55->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(create_app_options &a, create_app_options &b) {
  using ::std::swap;
  swap(a.partition_count, b.partition_count);
  swap(a.replica_count, b.replica_count);
  swap(a.success_if_exist, b.success_if_exist);
  swap(a.app_type, b.app_type);
  swap(a.is_stateful, b.is_stateful);
  swap(a.envs, b.envs);
  swap(a.__isset, b.__isset);
}

create_app_options::create_app_options(const create_app_options& other56) {
  partition_count = other56.partition_count;
  replica_count = other56.replica_count;
  success_if_exist = other56.success_if_exist;
  app_type = other56.app_type;
  is_stateful = other56.is_stateful;
  envs = other56.envs;
  __isset = other56.__isset;
}
create_app_options& create_app_options::operator=(const create_app_options& other57) {
  partition_count = other57.partition_count;
  replica_count = other57.replica_count;
  success_if_exist = other57.success_if_exist;
  app_type = other57.app_type;
  is_stateful = other57.is_stateful;
  envs = other57.envs;
  __isset = other57.__isset;
  return *this;
}
void create_app_options::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "create_app_options(";
  out << "partition_count=" << to_string(partition_count);
  out << ", " << "replica_count=" << to_string(replica_count);
  out << ", " << "success_if_exist=" << to_string(success_if_exist);
  out << ", " << "app_type=" << to_string(app_type);
  out << ", " << "is_stateful=" << to_string(is_stateful);
  out << ", " << "envs=" << to_string(envs);
  out << ")";
}


configuration_create_app_request::~configuration_create_app_request() throw() {
}


void configuration_create_app_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void configuration_create_app_request::__set_options(const create_app_options& val) {
  this->options = val;
}

uint32_t configuration_create_app_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_create_app_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_create_app_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->options.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_create_app_request &a, configuration_create_app_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

configuration_create_app_request::configuration_create_app_request(const configuration_create_app_request& other58) {
  app_name = other58.app_name;
  options = other58.options;
  __isset = other58.__isset;
}
configuration_create_app_request& configuration_create_app_request::operator=(const configuration_create_app_request& other59) {
  app_name = other59.app_name;
  options = other59.options;
  __isset = other59.__isset;
  return *this;
}
void configuration_create_app_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_create_app_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "options=" << to_string(options);
  out << ")";
}


configuration_create_app_response::~configuration_create_app_response() throw() {
}


void configuration_create_app_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_create_app_response::__set_appid(const int32_t val) {
  this->appid = val;
}

uint32_t configuration_create_app_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->appid);
          this->__isset.appid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_create_app_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_create_app_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->appid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_create_app_response &a, configuration_create_app_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.appid, b.appid);
  swap(a.__isset, b.__isset);
}

configuration_create_app_response::configuration_create_app_response(const configuration_create_app_response& other60) {
  err = other60.err;
  appid = other60.appid;
  __isset = other60.__isset;
}
configuration_create_app_response& configuration_create_app_response::operator=(const configuration_create_app_response& other61) {
  err = other61.err;
  appid = other61.appid;
  __isset = other61.__isset;
  return *this;
}
void configuration_create_app_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_create_app_response(";
  out << "err=" << to_string(err);
  out << ", " << "appid=" << to_string(appid);
  out << ")";
}


drop_app_options::~drop_app_options() throw() {
}


void drop_app_options::__set_success_if_not_exist(const bool val) {
  this->success_if_not_exist = val;
}

void drop_app_options::__set_reserve_seconds(const int64_t val) {
  this->reserve_seconds = val;
__isset.reserve_seconds = true;
}

uint32_t drop_app_options::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success_if_not_exist);
          this->__isset.success_if_not_exist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->reserve_seconds);
          this->__isset.reserve_seconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t drop_app_options::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("drop_app_options");

  xfer += oprot->writeFieldBegin("success_if_not_exist", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success_if_not_exist);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.reserve_seconds) {
    xfer += oprot->writeFieldBegin("reserve_seconds", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->reserve_seconds);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(drop_app_options &a, drop_app_options &b) {
  using ::std::swap;
  swap(a.success_if_not_exist, b.success_if_not_exist);
  swap(a.reserve_seconds, b.reserve_seconds);
  swap(a.__isset, b.__isset);
}

drop_app_options::drop_app_options(const drop_app_options& other62) {
  success_if_not_exist = other62.success_if_not_exist;
  reserve_seconds = other62.reserve_seconds;
  __isset = other62.__isset;
}
drop_app_options& drop_app_options::operator=(const drop_app_options& other63) {
  success_if_not_exist = other63.success_if_not_exist;
  reserve_seconds = other63.reserve_seconds;
  __isset = other63.__isset;
  return *this;
}
void drop_app_options::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "drop_app_options(";
  out << "success_if_not_exist=" << to_string(success_if_not_exist);
  out << ", " << "reserve_seconds="; (__isset.reserve_seconds ? (out << to_string(reserve_seconds)) : (out << "<null>"));
  out << ")";
}


configuration_drop_app_request::~configuration_drop_app_request() throw() {
}


void configuration_drop_app_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void configuration_drop_app_request::__set_options(const drop_app_options& val) {
  this->options = val;
}

uint32_t configuration_drop_app_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_drop_app_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_drop_app_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->options.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_drop_app_request &a, configuration_drop_app_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

configuration_drop_app_request::configuration_drop_app_request(const configuration_drop_app_request& other64) {
  app_name = other64.app_name;
  options = other64.options;
  __isset = other64.__isset;
}
configuration_drop_app_request& configuration_drop_app_request::operator=(const configuration_drop_app_request& other65) {
  app_name = other65.app_name;
  options = other65.options;
  __isset = other65.__isset;
  return *this;
}
void configuration_drop_app_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_drop_app_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "options=" << to_string(options);
  out << ")";
}


configuration_drop_app_response::~configuration_drop_app_response() throw() {
}


void configuration_drop_app_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

uint32_t configuration_drop_app_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_drop_app_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_drop_app_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_drop_app_response &a, configuration_drop_app_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

configuration_drop_app_response::configuration_drop_app_response(const configuration_drop_app_response& other66) {
  err = other66.err;
  __isset = other66.__isset;
}
configuration_drop_app_response& configuration_drop_app_response::operator=(const configuration_drop_app_response& other67) {
  err = other67.err;
  __isset = other67.__isset;
  return *this;
}
void configuration_drop_app_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_drop_app_response(";
  out << "err=" << to_string(err);
  out << ")";
}


configuration_recall_app_request::~configuration_recall_app_request() throw() {
}


void configuration_recall_app_request::__set_app_id(const int32_t val) {
  this->app_id = val;
}

void configuration_recall_app_request::__set_new_app_name(const std::string& val) {
  this->new_app_name = val;
}

uint32_t configuration_recall_app_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->app_id);
          this->__isset.app_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->new_app_name);
          this->__isset.new_app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_recall_app_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_recall_app_request");

  xfer += oprot->writeFieldBegin("app_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->app_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("new_app_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->new_app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_recall_app_request &a, configuration_recall_app_request &b) {
  using ::std::swap;
  swap(a.app_id, b.app_id);
  swap(a.new_app_name, b.new_app_name);
  swap(a.__isset, b.__isset);
}

configuration_recall_app_request::configuration_recall_app_request(const configuration_recall_app_request& other68) {
  app_id = other68.app_id;
  new_app_name = other68.new_app_name;
  __isset = other68.__isset;
}
configuration_recall_app_request& configuration_recall_app_request::operator=(const configuration_recall_app_request& other69) {
  app_id = other69.app_id;
  new_app_name = other69.new_app_name;
  __isset = other69.__isset;
  return *this;
}
void configuration_recall_app_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_recall_app_request(";
  out << "app_id=" << to_string(app_id);
  out << ", " << "new_app_name=" << to_string(new_app_name);
  out << ")";
}


configuration_recall_app_response::~configuration_recall_app_response() throw() {
}


void configuration_recall_app_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_recall_app_response::__set_info(const  ::dsn::app_info& val) {
  this->info = val;
}

uint32_t configuration_recall_app_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->info.read(iprot);
          this->__isset.info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_recall_app_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_recall_app_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("info", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->info.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_recall_app_response &a, configuration_recall_app_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.info, b.info);
  swap(a.__isset, b.__isset);
}

configuration_recall_app_response::configuration_recall_app_response(const configuration_recall_app_response& other70) {
  err = other70.err;
  info = other70.info;
  __isset = other70.__isset;
}
configuration_recall_app_response& configuration_recall_app_response::operator=(const configuration_recall_app_response& other71) {
  err = other71.err;
  info = other71.info;
  __isset = other71.__isset;
  return *this;
}
void configuration_recall_app_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_recall_app_response(";
  out << "err=" << to_string(err);
  out << ", " << "info=" << to_string(info);
  out << ")";
}


configuration_list_apps_request::~configuration_list_apps_request() throw() {
}


void configuration_list_apps_request::__set_status(const  ::dsn::app_status::type val) {
  this->status = val;
}

uint32_t configuration_list_apps_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast72;
          xfer += iprot->readI32(ecast72);
          this->status = ( ::dsn::app_status::type)ecast72;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_list_apps_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_list_apps_request");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_list_apps_request &a, configuration_list_apps_request &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

configuration_list_apps_request::configuration_list_apps_request(const configuration_list_apps_request& other73) {
  status = other73.status;
  __isset = other73.__isset;
}
configuration_list_apps_request& configuration_list_apps_request::operator=(const configuration_list_apps_request& other74) {
  status = other74.status;
  __isset = other74.__isset;
  return *this;
}
void configuration_list_apps_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_list_apps_request(";
  out << "status=" << to_string(status);
  out << ")";
}


configuration_list_apps_response::~configuration_list_apps_response() throw() {
}


void configuration_list_apps_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_list_apps_response::__set_infos(const std::vector< ::dsn::app_info> & val) {
  this->infos = val;
}

uint32_t configuration_list_apps_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->infos.clear();
            uint32_t _size75;
            ::apache::thrift::protocol::TType _etype78;
            xfer += iprot->readListBegin(_etype78, _size75);
            this->infos.resize(_size75);
            uint32_t _i79;
            for (_i79 = 0; _i79 < _size75; ++_i79)
            {
              xfer += this->infos[_i79].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_list_apps_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_list_apps_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infos", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->infos.size()));
    std::vector< ::dsn::app_info> ::const_iterator _iter80;
    for (_iter80 = this->infos.begin(); _iter80 != this->infos.end(); ++_iter80)
    {
      xfer += (*_iter80).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_list_apps_response &a, configuration_list_apps_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.infos, b.infos);
  swap(a.__isset, b.__isset);
}

configuration_list_apps_response::configuration_list_apps_response(const configuration_list_apps_response& other81) {
  err = other81.err;
  infos = other81.infos;
  __isset = other81.__isset;
}
configuration_list_apps_response& configuration_list_apps_response::operator=(const configuration_list_apps_response& other82) {
  err = other82.err;
  infos = other82.infos;
  __isset = other82.__isset;
  return *this;
}
void configuration_list_apps_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_list_apps_response(";
  out << "err=" << to_string(err);
  out << ", " << "infos=" << to_string(infos);
  out << ")";
}


query_app_info_request::~query_app_info_request() throw() {
}


void query_app_info_request::__set_meta_server(const  ::dsn::rpc_address& val) {
  this->meta_server = val;
}

uint32_t query_app_info_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->meta_server.read(iprot);
          this->__isset.meta_server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_app_info_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_app_info_request");

  xfer += oprot->writeFieldBegin("meta_server", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->meta_server.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_app_info_request &a, query_app_info_request &b) {
  using ::std::swap;
  swap(a.meta_server, b.meta_server);
  swap(a.__isset, b.__isset);
}

query_app_info_request::query_app_info_request(const query_app_info_request& other83) {
  meta_server = other83.meta_server;
  __isset = other83.__isset;
}
query_app_info_request& query_app_info_request::operator=(const query_app_info_request& other84) {
  meta_server = other84.meta_server;
  __isset = other84.__isset;
  return *this;
}
void query_app_info_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_app_info_request(";
  out << "meta_server=" << to_string(meta_server);
  out << ")";
}


query_app_info_response::~query_app_info_response() throw() {
}


void query_app_info_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void query_app_info_response::__set_apps(const std::vector< ::dsn::app_info> & val) {
  this->apps = val;
}

uint32_t query_app_info_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->apps.clear();
            uint32_t _size85;
            ::apache::thrift::protocol::TType _etype88;
            xfer += iprot->readListBegin(_etype88, _size85);
            this->apps.resize(_size85);
            uint32_t _i89;
            for (_i89 = 0; _i89 < _size85; ++_i89)
            {
              xfer += this->apps[_i89].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.apps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_app_info_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_app_info_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("apps", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->apps.size()));
    std::vector< ::dsn::app_info> ::const_iterator _iter90;
    for (_iter90 = this->apps.begin(); _iter90 != this->apps.end(); ++_iter90)
    {
      xfer += (*_iter90).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_app_info_response &a, query_app_info_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.apps, b.apps);
  swap(a.__isset, b.__isset);
}

query_app_info_response::query_app_info_response(const query_app_info_response& other91) {
  err = other91.err;
  apps = other91.apps;
  __isset = other91.__isset;
}
query_app_info_response& query_app_info_response::operator=(const query_app_info_response& other92) {
  err = other92.err;
  apps = other92.apps;
  __isset = other92.__isset;
  return *this;
}
void query_app_info_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_app_info_response(";
  out << "err=" << to_string(err);
  out << ", " << "apps=" << to_string(apps);
  out << ")";
}


configuration_update_app_env_request::~configuration_update_app_env_request() throw() {
}


void configuration_update_app_env_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void configuration_update_app_env_request::__set_op(const app_env_operation::type val) {
  this->op = val;
}

void configuration_update_app_env_request::__set_keys(const std::vector<std::string> & val) {
  this->keys = val;
__isset.keys = true;
}

void configuration_update_app_env_request::__set_values(const std::vector<std::string> & val) {
  this->values = val;
__isset.values = true;
}

void configuration_update_app_env_request::__set_clear_prefix(const std::string& val) {
  this->clear_prefix = val;
__isset.clear_prefix = true;
}

uint32_t configuration_update_app_env_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast93;
          xfer += iprot->readI32(ecast93);
          this->op = (app_env_operation::type)ecast93;
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->keys.clear();
            uint32_t _size94;
            ::apache::thrift::protocol::TType _etype97;
            xfer += iprot->readListBegin(_etype97, _size94);
            this->keys.resize(_size94);
            uint32_t _i98;
            for (_i98 = 0; _i98 < _size94; ++_i98)
            {
              xfer += iprot->readString(this->keys[_i98]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.keys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size99;
            ::apache::thrift::protocol::TType _etype102;
            xfer += iprot->readListBegin(_etype102, _size99);
            this->values.resize(_size99);
            uint32_t _i103;
            for (_i103 = 0; _i103 < _size99; ++_i103)
            {
              xfer += iprot->readString(this->values[_i103]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clear_prefix);
          this->__isset.clear_prefix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_update_app_env_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_update_app_env_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->op);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.keys) {
    xfer += oprot->writeFieldBegin("keys", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->keys.size()));
      std::vector<std::string> ::const_iterator _iter104;
      for (_iter104 = this->keys.begin(); _iter104 != this->keys.end(); ++_iter104)
      {
        xfer += oprot->writeString((*_iter104));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.values) {
    xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
      std::vector<std::string> ::const_iterator _iter105;
      for (_iter105 = this->values.begin(); _iter105 != this->values.end(); ++_iter105)
      {
        xfer += oprot->writeString((*_iter105));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clear_prefix) {
    xfer += oprot->writeFieldBegin("clear_prefix", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->clear_prefix);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_update_app_env_request &a, configuration_update_app_env_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.op, b.op);
  swap(a.keys, b.keys);
  swap(a.values, b.values);
  swap(a.clear_prefix, b.clear_prefix);
  swap(a.__isset, b.__isset);
}

configuration_update_app_env_request::configuration_update_app_env_request(const configuration_update_app_env_request& other106) {
  app_name = other106.app_name;
  op = other106.op;
  keys = other106.keys;
  values = other106.values;
  clear_prefix = other106.clear_prefix;
  __isset = other106.__isset;
}
configuration_update_app_env_request& configuration_update_app_env_request::operator=(const configuration_update_app_env_request& other107) {
  app_name = other107.app_name;
  op = other107.op;
  keys = other107.keys;
  values = other107.values;
  clear_prefix = other107.clear_prefix;
  __isset = other107.__isset;
  return *this;
}
void configuration_update_app_env_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_update_app_env_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "op=" << to_string(op);
  out << ", " << "keys="; (__isset.keys ? (out << to_string(keys)) : (out << "<null>"));
  out << ", " << "values="; (__isset.values ? (out << to_string(values)) : (out << "<null>"));
  out << ", " << "clear_prefix="; (__isset.clear_prefix ? (out << to_string(clear_prefix)) : (out << "<null>"));
  out << ")";
}


configuration_update_app_env_response::~configuration_update_app_env_response() throw() {
}


void configuration_update_app_env_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_update_app_env_response::__set_hint_message(const std::string& val) {
  this->hint_message = val;
}

uint32_t configuration_update_app_env_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_message);
          this->__isset.hint_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_update_app_env_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_update_app_env_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hint_message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hint_message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_update_app_env_response &a, configuration_update_app_env_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.hint_message, b.hint_message);
  swap(a.__isset, b.__isset);
}

configuration_update_app_env_response::configuration_update_app_env_response(const configuration_update_app_env_response& other108) {
  err = other108.err;
  hint_message = other108.hint_message;
  __isset = other108.__isset;
}
configuration_update_app_env_response& configuration_update_app_env_response::operator=(const configuration_update_app_env_response& other109) {
  err = other109.err;
  hint_message = other109.hint_message;
  __isset = other109.__isset;
  return *this;
}
void configuration_update_app_env_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_update_app_env_response(";
  out << "err=" << to_string(err);
  out << ", " << "hint_message=" << to_string(hint_message);
  out << ")";
}


node_info::~node_info() throw() {
}


void node_info::__set_status(const node_status::type val) {
  this->status = val;
}

void node_info::__set_address(const  ::dsn::rpc_address& val) {
  this->address = val;
}

uint32_t node_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast110;
          xfer += iprot->readI32(ecast110);
          this->status = (node_status::type)ecast110;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->address.read(iprot);
          this->__isset.address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_info");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->address.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_info &a, node_info &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.address, b.address);
  swap(a.__isset, b.__isset);
}

node_info::node_info(const node_info& other111) {
  status = other111.status;
  address = other111.address;
  __isset = other111.__isset;
}
node_info& node_info::operator=(const node_info& other112) {
  status = other112.status;
  address = other112.address;
  __isset = other112.__isset;
  return *this;
}
void node_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_info(";
  out << "status=" << to_string(status);
  out << ", " << "address=" << to_string(address);
  out << ")";
}


configuration_list_nodes_request::~configuration_list_nodes_request() throw() {
}


void configuration_list_nodes_request::__set_status(const node_status::type val) {
  this->status = val;
}

uint32_t configuration_list_nodes_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast113;
          xfer += iprot->readI32(ecast113);
          this->status = (node_status::type)ecast113;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_list_nodes_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_list_nodes_request");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_list_nodes_request &a, configuration_list_nodes_request &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

configuration_list_nodes_request::configuration_list_nodes_request(const configuration_list_nodes_request& other114) {
  status = other114.status;
  __isset = other114.__isset;
}
configuration_list_nodes_request& configuration_list_nodes_request::operator=(const configuration_list_nodes_request& other115) {
  status = other115.status;
  __isset = other115.__isset;
  return *this;
}
void configuration_list_nodes_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_list_nodes_request(";
  out << "status=" << to_string(status);
  out << ")";
}


configuration_list_nodes_response::~configuration_list_nodes_response() throw() {
}


void configuration_list_nodes_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_list_nodes_response::__set_infos(const std::vector<node_info> & val) {
  this->infos = val;
}

uint32_t configuration_list_nodes_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->infos.clear();
            uint32_t _size116;
            ::apache::thrift::protocol::TType _etype119;
            xfer += iprot->readListBegin(_etype119, _size116);
            this->infos.resize(_size116);
            uint32_t _i120;
            for (_i120 = 0; _i120 < _size116; ++_i120)
            {
              xfer += this->infos[_i120].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_list_nodes_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_list_nodes_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infos", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->infos.size()));
    std::vector<node_info> ::const_iterator _iter121;
    for (_iter121 = this->infos.begin(); _iter121 != this->infos.end(); ++_iter121)
    {
      xfer += (*_iter121).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_list_nodes_response &a, configuration_list_nodes_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.infos, b.infos);
  swap(a.__isset, b.__isset);
}

configuration_list_nodes_response::configuration_list_nodes_response(const configuration_list_nodes_response& other122) {
  err = other122.err;
  infos = other122.infos;
  __isset = other122.__isset;
}
configuration_list_nodes_response& configuration_list_nodes_response::operator=(const configuration_list_nodes_response& other123) {
  err = other123.err;
  infos = other123.infos;
  __isset = other123.__isset;
  return *this;
}
void configuration_list_nodes_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_list_nodes_response(";
  out << "err=" << to_string(err);
  out << ", " << "infos=" << to_string(infos);
  out << ")";
}


configuration_cluster_info_request::~configuration_cluster_info_request() throw() {
}


uint32_t configuration_cluster_info_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_cluster_info_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_cluster_info_request");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_cluster_info_request &a, configuration_cluster_info_request &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

configuration_cluster_info_request::configuration_cluster_info_request(const configuration_cluster_info_request& other124) {
  (void) other124;
}
configuration_cluster_info_request& configuration_cluster_info_request::operator=(const configuration_cluster_info_request& other125) {
  (void) other125;
  return *this;
}
void configuration_cluster_info_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_cluster_info_request(";
  out << ")";
}


configuration_cluster_info_response::~configuration_cluster_info_response() throw() {
}


void configuration_cluster_info_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_cluster_info_response::__set_keys(const std::vector<std::string> & val) {
  this->keys = val;
}

void configuration_cluster_info_response::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

uint32_t configuration_cluster_info_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->keys.clear();
            uint32_t _size126;
            ::apache::thrift::protocol::TType _etype129;
            xfer += iprot->readListBegin(_etype129, _size126);
            this->keys.resize(_size126);
            uint32_t _i130;
            for (_i130 = 0; _i130 < _size126; ++_i130)
            {
              xfer += iprot->readString(this->keys[_i130]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.keys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size131;
            ::apache::thrift::protocol::TType _etype134;
            xfer += iprot->readListBegin(_etype134, _size131);
            this->values.resize(_size131);
            uint32_t _i135;
            for (_i135 = 0; _i135 < _size131; ++_i135)
            {
              xfer += iprot->readString(this->values[_i135]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_cluster_info_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_cluster_info_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("keys", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->keys.size()));
    std::vector<std::string> ::const_iterator _iter136;
    for (_iter136 = this->keys.begin(); _iter136 != this->keys.end(); ++_iter136)
    {
      xfer += oprot->writeString((*_iter136));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter137;
    for (_iter137 = this->values.begin(); _iter137 != this->values.end(); ++_iter137)
    {
      xfer += oprot->writeString((*_iter137));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_cluster_info_response &a, configuration_cluster_info_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.keys, b.keys);
  swap(a.values, b.values);
  swap(a.__isset, b.__isset);
}

configuration_cluster_info_response::configuration_cluster_info_response(const configuration_cluster_info_response& other138) {
  err = other138.err;
  keys = other138.keys;
  values = other138.values;
  __isset = other138.__isset;
}
configuration_cluster_info_response& configuration_cluster_info_response::operator=(const configuration_cluster_info_response& other139) {
  err = other139.err;
  keys = other139.keys;
  values = other139.values;
  __isset = other139.__isset;
  return *this;
}
void configuration_cluster_info_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_cluster_info_response(";
  out << "err=" << to_string(err);
  out << ", " << "keys=" << to_string(keys);
  out << ", " << "values=" << to_string(values);
  out << ")";
}


configuration_meta_control_request::~configuration_meta_control_request() throw() {
}


void configuration_meta_control_request::__set_level(const meta_function_level::type val) {
  this->level = val;
}

uint32_t configuration_meta_control_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast140;
          xfer += iprot->readI32(ecast140);
          this->level = (meta_function_level::type)ecast140;
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_meta_control_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_meta_control_request");

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_meta_control_request &a, configuration_meta_control_request &b) {
  using ::std::swap;
  swap(a.level, b.level);
  swap(a.__isset, b.__isset);
}

configuration_meta_control_request::configuration_meta_control_request(const configuration_meta_control_request& other141) {
  level = other141.level;
  __isset = other141.__isset;
}
configuration_meta_control_request& configuration_meta_control_request::operator=(const configuration_meta_control_request& other142) {
  level = other142.level;
  __isset = other142.__isset;
  return *this;
}
void configuration_meta_control_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_meta_control_request(";
  out << "level=" << to_string(level);
  out << ")";
}


configuration_meta_control_response::~configuration_meta_control_response() throw() {
}


void configuration_meta_control_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_meta_control_response::__set_old_level(const meta_function_level::type val) {
  this->old_level = val;
}

uint32_t configuration_meta_control_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast143;
          xfer += iprot->readI32(ecast143);
          this->old_level = (meta_function_level::type)ecast143;
          this->__isset.old_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_meta_control_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_meta_control_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("old_level", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->old_level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_meta_control_response &a, configuration_meta_control_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.old_level, b.old_level);
  swap(a.__isset, b.__isset);
}

configuration_meta_control_response::configuration_meta_control_response(const configuration_meta_control_response& other144) {
  err = other144.err;
  old_level = other144.old_level;
  __isset = other144.__isset;
}
configuration_meta_control_response& configuration_meta_control_response::operator=(const configuration_meta_control_response& other145) {
  err = other145.err;
  old_level = other145.old_level;
  __isset = other145.__isset;
  return *this;
}
void configuration_meta_control_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_meta_control_response(";
  out << "err=" << to_string(err);
  out << ", " << "old_level=" << to_string(old_level);
  out << ")";
}


configuration_proposal_action::~configuration_proposal_action() throw() {
}


void configuration_proposal_action::__set_target(const  ::dsn::rpc_address& val) {
  this->target = val;
}

void configuration_proposal_action::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

void configuration_proposal_action::__set_type(const config_type::type val) {
  this->type = val;
}

uint32_t configuration_proposal_action::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->target.read(iprot);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast146;
          xfer += iprot->readI32(ecast146);
          this->type = (config_type::type)ecast146;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_proposal_action::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_proposal_action");

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->target.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_proposal_action &a, configuration_proposal_action &b) {
  using ::std::swap;
  swap(a.target, b.target);
  swap(a.node, b.node);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

configuration_proposal_action::configuration_proposal_action(const configuration_proposal_action& other147) {
  target = other147.target;
  node = other147.node;
  type = other147.type;
  __isset = other147.__isset;
}
configuration_proposal_action& configuration_proposal_action::operator=(const configuration_proposal_action& other148) {
  target = other148.target;
  node = other148.node;
  type = other148.type;
  __isset = other148.__isset;
  return *this;
}
void configuration_proposal_action::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_proposal_action(";
  out << "target=" << to_string(target);
  out << ", " << "node=" << to_string(node);
  out << ", " << "type=" << to_string(type);
  out << ")";
}


configuration_balancer_request::~configuration_balancer_request() throw() {
}


void configuration_balancer_request::__set_gpid(const  ::dsn::gpid& val) {
  this->gpid = val;
}

void configuration_balancer_request::__set_action_list(const std::vector<configuration_proposal_action> & val) {
  this->action_list = val;
}

void configuration_balancer_request::__set_force(const bool val) {
  this->force = val;
__isset.force = true;
}

void configuration_balancer_request::__set_balance_type(const balancer_request_type::type val) {
  this->balance_type = val;
__isset.balance_type = true;
}

uint32_t configuration_balancer_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gpid.read(iprot);
          this->__isset.gpid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->action_list.clear();
            uint32_t _size149;
            ::apache::thrift::protocol::TType _etype152;
            xfer += iprot->readListBegin(_etype152, _size149);
            this->action_list.resize(_size149);
            uint32_t _i153;
            for (_i153 = 0; _i153 < _size149; ++_i153)
            {
              xfer += this->action_list[_i153].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.action_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->force);
          this->__isset.force = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast154;
          xfer += iprot->readI32(ecast154);
          this->balance_type = (balancer_request_type::type)ecast154;
          this->__isset.balance_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_balancer_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_balancer_request");

  xfer += oprot->writeFieldBegin("gpid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->gpid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("action_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->action_list.size()));
    std::vector<configuration_proposal_action> ::const_iterator _iter155;
    for (_iter155 = this->action_list.begin(); _iter155 != this->action_list.end(); ++_iter155)
    {
      xfer += (*_iter155).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.force) {
    xfer += oprot->writeFieldBegin("force", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->force);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.balance_type) {
    xfer += oprot->writeFieldBegin("balance_type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->balance_type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_balancer_request &a, configuration_balancer_request &b) {
  using ::std::swap;
  swap(a.gpid, b.gpid);
  swap(a.action_list, b.action_list);
  swap(a.force, b.force);
  swap(a.balance_type, b.balance_type);
  swap(a.__isset, b.__isset);
}

configuration_balancer_request::configuration_balancer_request(const configuration_balancer_request& other156) {
  gpid = other156.gpid;
  action_list = other156.action_list;
  force = other156.force;
  balance_type = other156.balance_type;
  __isset = other156.__isset;
}
configuration_balancer_request& configuration_balancer_request::operator=(const configuration_balancer_request& other157) {
  gpid = other157.gpid;
  action_list = other157.action_list;
  force = other157.force;
  balance_type = other157.balance_type;
  __isset = other157.__isset;
  return *this;
}
void configuration_balancer_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_balancer_request(";
  out << "gpid=" << to_string(gpid);
  out << ", " << "action_list=" << to_string(action_list);
  out << ", " << "force="; (__isset.force ? (out << to_string(force)) : (out << "<null>"));
  out << ", " << "balance_type="; (__isset.balance_type ? (out << to_string(balance_type)) : (out << "<null>"));
  out << ")";
}


configuration_balancer_response::~configuration_balancer_response() throw() {
}


void configuration_balancer_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

uint32_t configuration_balancer_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_balancer_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_balancer_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_balancer_response &a, configuration_balancer_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

configuration_balancer_response::configuration_balancer_response(const configuration_balancer_response& other158) {
  err = other158.err;
  __isset = other158.__isset;
}
configuration_balancer_response& configuration_balancer_response::operator=(const configuration_balancer_response& other159) {
  err = other159.err;
  __isset = other159.__isset;
  return *this;
}
void configuration_balancer_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_balancer_response(";
  out << "err=" << to_string(err);
  out << ")";
}


ddd_diagnose_request::~ddd_diagnose_request() throw() {
}


void ddd_diagnose_request::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

uint32_t ddd_diagnose_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ddd_diagnose_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ddd_diagnose_request");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ddd_diagnose_request &a, ddd_diagnose_request &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.__isset, b.__isset);
}

ddd_diagnose_request::ddd_diagnose_request(const ddd_diagnose_request& other160) {
  pid = other160.pid;
  __isset = other160.__isset;
}
ddd_diagnose_request& ddd_diagnose_request::operator=(const ddd_diagnose_request& other161) {
  pid = other161.pid;
  __isset = other161.__isset;
  return *this;
}
void ddd_diagnose_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ddd_diagnose_request(";
  out << "pid=" << to_string(pid);
  out << ")";
}


ddd_node_info::~ddd_node_info() throw() {
}


void ddd_node_info::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

void ddd_node_info::__set_drop_time_ms(const int64_t val) {
  this->drop_time_ms = val;
}

void ddd_node_info::__set_is_alive(const bool val) {
  this->is_alive = val;
}

void ddd_node_info::__set_is_collected(const bool val) {
  this->is_collected = val;
}

void ddd_node_info::__set_ballot(const int64_t val) {
  this->ballot = val;
}

void ddd_node_info::__set_last_committed_decree(const int64_t val) {
  this->last_committed_decree = val;
}

void ddd_node_info::__set_last_prepared_decree(const int64_t val) {
  this->last_prepared_decree = val;
}

uint32_t ddd_node_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->drop_time_ms);
          this->__isset.drop_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_alive);
          this->__isset.is_alive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_collected);
          this->__isset.is_collected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ballot);
          this->__isset.ballot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree);
          this->__isset.last_committed_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_prepared_decree);
          this->__isset.last_prepared_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ddd_node_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ddd_node_info");

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("drop_time_ms", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->drop_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_alive", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_alive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_collected", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_collected);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->ballot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->last_committed_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_prepared_decree", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->last_prepared_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ddd_node_info &a, ddd_node_info &b) {
  using ::std::swap;
  swap(a.node, b.node);
  swap(a.drop_time_ms, b.drop_time_ms);
  swap(a.is_alive, b.is_alive);
  swap(a.is_collected, b.is_collected);
  swap(a.ballot, b.ballot);
  swap(a.last_committed_decree, b.last_committed_decree);
  swap(a.last_prepared_decree, b.last_prepared_decree);
  swap(a.__isset, b.__isset);
}

ddd_node_info::ddd_node_info(const ddd_node_info& other162) {
  node = other162.node;
  drop_time_ms = other162.drop_time_ms;
  is_alive = other162.is_alive;
  is_collected = other162.is_collected;
  ballot = other162.ballot;
  last_committed_decree = other162.last_committed_decree;
  last_prepared_decree = other162.last_prepared_decree;
  __isset = other162.__isset;
}
ddd_node_info& ddd_node_info::operator=(const ddd_node_info& other163) {
  node = other163.node;
  drop_time_ms = other163.drop_time_ms;
  is_alive = other163.is_alive;
  is_collected = other163.is_collected;
  ballot = other163.ballot;
  last_committed_decree = other163.last_committed_decree;
  last_prepared_decree = other163.last_prepared_decree;
  __isset = other163.__isset;
  return *this;
}
void ddd_node_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ddd_node_info(";
  out << "node=" << to_string(node);
  out << ", " << "drop_time_ms=" << to_string(drop_time_ms);
  out << ", " << "is_alive=" << to_string(is_alive);
  out << ", " << "is_collected=" << to_string(is_collected);
  out << ", " << "ballot=" << to_string(ballot);
  out << ", " << "last_committed_decree=" << to_string(last_committed_decree);
  out << ", " << "last_prepared_decree=" << to_string(last_prepared_decree);
  out << ")";
}


ddd_partition_info::~ddd_partition_info() throw() {
}


void ddd_partition_info::__set_config(const  ::dsn::partition_configuration& val) {
  this->config = val;
}

void ddd_partition_info::__set_dropped(const std::vector<ddd_node_info> & val) {
  this->dropped = val;
}

void ddd_partition_info::__set_reason(const std::string& val) {
  this->reason = val;
}

uint32_t ddd_partition_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->config.read(iprot);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dropped.clear();
            uint32_t _size164;
            ::apache::thrift::protocol::TType _etype167;
            xfer += iprot->readListBegin(_etype167, _size164);
            this->dropped.resize(_size164);
            uint32_t _i168;
            for (_i168 = 0; _i168 < _size164; ++_i168)
            {
              xfer += this->dropped[_i168].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dropped = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          this->__isset.reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ddd_partition_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ddd_partition_info");

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dropped", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dropped.size()));
    std::vector<ddd_node_info> ::const_iterator _iter169;
    for (_iter169 = this->dropped.begin(); _iter169 != this->dropped.end(); ++_iter169)
    {
      xfer += (*_iter169).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ddd_partition_info &a, ddd_partition_info &b) {
  using ::std::swap;
  swap(a.config, b.config);
  swap(a.dropped, b.dropped);
  swap(a.reason, b.reason);
  swap(a.__isset, b.__isset);
}

ddd_partition_info::ddd_partition_info(const ddd_partition_info& other170) {
  config = other170.config;
  dropped = other170.dropped;
  reason = other170.reason;
  __isset = other170.__isset;
}
ddd_partition_info& ddd_partition_info::operator=(const ddd_partition_info& other171) {
  config = other171.config;
  dropped = other171.dropped;
  reason = other171.reason;
  __isset = other171.__isset;
  return *this;
}
void ddd_partition_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ddd_partition_info(";
  out << "config=" << to_string(config);
  out << ", " << "dropped=" << to_string(dropped);
  out << ", " << "reason=" << to_string(reason);
  out << ")";
}


ddd_diagnose_response::~ddd_diagnose_response() throw() {
}


void ddd_diagnose_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void ddd_diagnose_response::__set_partitions(const std::vector<ddd_partition_info> & val) {
  this->partitions = val;
}

uint32_t ddd_diagnose_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size172;
            ::apache::thrift::protocol::TType _etype175;
            xfer += iprot->readListBegin(_etype175, _size172);
            this->partitions.resize(_size172);
            uint32_t _i176;
            for (_i176 = 0; _i176 < _size172; ++_i176)
            {
              xfer += this->partitions[_i176].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ddd_diagnose_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ddd_diagnose_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<ddd_partition_info> ::const_iterator _iter177;
    for (_iter177 = this->partitions.begin(); _iter177 != this->partitions.end(); ++_iter177)
    {
      xfer += (*_iter177).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ddd_diagnose_response &a, ddd_diagnose_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.partitions, b.partitions);
  swap(a.__isset, b.__isset);
}

ddd_diagnose_response::ddd_diagnose_response(const ddd_diagnose_response& other178) {
  err = other178.err;
  partitions = other178.partitions;
  __isset = other178.__isset;
}
ddd_diagnose_response& ddd_diagnose_response::operator=(const ddd_diagnose_response& other179) {
  err = other179.err;
  partitions = other179.partitions;
  __isset = other179.__isset;
  return *this;
}
void ddd_diagnose_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ddd_diagnose_response(";
  out << "err=" << to_string(err);
  out << ", " << "partitions=" << to_string(partitions);
  out << ")";
}

}} // namespace
